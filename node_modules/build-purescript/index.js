'use strict';

const inspect = require('util').inspect;
const pathLib = require('path');
const osTmpdir = require('os').tmpdir;
const stat = require('fs').stat;

const join = pathLib.join;
const resolve = pathLib.resolve;

const downloadPurescriptSource = require('download-purescript-source');
const feint = require('feint');
const gracefulFs = require('graceful-fs');
const inspectWithKind = require('inspect-with-kind');
const isPlainObj = require('is-plain-obj');
const minimist = require('minimist');
const mkdirp = require('mkdirp');
const Observable = require('zen-observable');
const once = require('once');
const rimraf = require('rimraf');
const spawnStack = require('spawn-stack');
const uid2 = require('uid2');

const DIR_ERROR = 'Expected a path where the PureScript binary should be built (string)';
const SOURCE_DIR_ERROR = 'Expected `sourceDir` option to be a path where PureScript source files are temporally downloaded';
const ARGS_ERROR = 'Expected `args` option to be an array of user defined arguments passed to `stack setup` and `stack install`';

const buildOnlyArgs = new Set([
	'--dry-run',
	'--pedantic',
	'--fast',
	'--only-snapshot',
	'--only-dependencies',
	'--only-configure',
	'--trace',
	'--profile',
	'--no-strip',
	'--coverage',
	'--no-run-tests',
	'--no-run-benchmarks'
]);

const negligibleLineRe = /^WARNING: (?:filepath wildcard|(?:File|Directory) listed|Installation path|Specified pattern) .*/i;

module.exports = function buildPurescript(dir, options) {
	return new Observable(observer => {
		if (typeof dir !== 'string') {
			throw new TypeError(`${DIR_ERROR}, but got a non-string value ${inspect(dir)}.`);
		}

		if (dir.length === 0) {
			throw new TypeError(`${DIR_ERROR}, but got '' (empty string).`);
		}

		if (options !== undefined) {
			if (!isPlainObj(options)) {
				throw new TypeError(`Expected build-purescript option to be an object, but got ${
					inspectWithKind(options)
				}.`);
			}

			if (options.sourceDir !== undefined) {
				if (typeof options.sourceDir !== 'string') {
					throw new TypeError(`${SOURCE_DIR_ERROR}, but got a non-string value ${
						inspectWithKind(options.sourceDir)
					}.`);
				}

				if (options.sourceDir.length === 0) {
					throw new Error(`${SOURCE_DIR_ERROR}, but got '' (empty string).`);
				}
			}

			if (options.cwd !== undefined) {
				throw new Error(`build-purescript doesn't support \`cwd\` option, but ${
					inspectWithKind(options.cwd)
				} was provided.`);
			}

			if (options.args !== undefined) {
				if (!Array.isArray(options.args)) {
					throw new TypeError(`${ARGS_ERROR}, but got a non-array value ${
						inspectWithKind(options.args)
					}.`);
				}
			}
		} else {
			options = {};
		}

		const subscriptions = new Set();
		const sourceDir = options.sourceDir ? resolve(options.sourceDir) : join(osTmpdir(), uid2(20));
		const installArgs = [
			'install',
			`--local-bin-path=${resolve(dir)}`,
			'--flag=purescript:RELEASE'
		];
		const defaultArgs = options.args ? options.args.filter(arg => {
			if (buildOnlyArgs.has(arg)) {
				installArgs.push(arg);
				return false;
			}

			return true;
		}) : [];
		const flags = Object.keys(minimist(defaultArgs), {
			alias: {
				j: ['jobs']
			}
		});
		const spawnOptions = Object.assign({cwd: sourceDir}, options);

		if (flags.indexOf('local-bin-path') !== -1) {
			throw new Error(`\`--local-bin-path\` flag is provided to the \`stack\` command, but it will be automatically set to ${
				inspect(sourceDir)
			} and cannot be modified via te flag.`);
		}

		let createdDir;
		let cleanupSourceDir = cb => rimraf(sourceDir, {glob: false}, cb);

		function sendError(err, id) {
			Object.defineProperty(err, 'id', {
				value: id,
				configurable: true,
				writable: true
			});

			if (createdDir) {
				rimraf(createdDir, {glob: false}, () => observer.error(err));
				return;
			}

			observer.error(err);
		}

		stat(sourceDir, (err, sourceDirStat) => {
			if (err) {
				return;
			}

			if (sourceDirStat.isDirectory()) {
				cleanupSourceDir = cb => cb();
				return;
			}

			const error = new Error(`Tried to download PureScript source to ${sourceDir}, but a file already exits there.`);
			error.code = 'EEXIST';
			error.syscall = 'mkdir';
			error.path = sourceDir;

			sendError(error, 'download');
		});

		const setupArgs = defaultArgs.concat(['setup']);
		const setupCommand = `stack ${setupArgs.join(' ')}`;

		const buildArgs = defaultArgs.concat(installArgs);
		const buildCommand = `stack ${buildArgs.join(' ')}`;

		const startBuildOnReady = feint(() => {
			subscriptions.add(Observable.from(spawnStack(buildArgs, spawnOptions)).subscribe({
				next(line) {
					if (negligibleLineRe.test(line)) {
						return;
					}

					observer.next({
						id: 'build',
						command: buildCommand,
						output: line
					});
				},
				error(err) {
					const negligibleMultiLineRe = new RegExp(`${negligibleLineRe.source}\\n\\r?`, 'gim');

					err.message = err.message.replace(negligibleMultiLineRe, '');
					err.stack = err.stack.replace(negligibleMultiLineRe, '');

					cleanupSourceDir(() => sendError(err, 'build'));
				},
				complete() {
					cleanupSourceDir(() => {
						observer.next({id: 'build:complete'});
						observer.complete();
					});
				}
			}));
		});

		const setup = once(() => {
			mkdirp(dir, {fs: gracefulFs}, (mkdirErr, firstDir) => {
				if (mkdirErr) {
					sendError(mkdirErr, 'setup');
					return;
				}

				if (firstDir) {
					createdDir = firstDir;
				}

				subscriptions.add(Observable.from(spawnStack(setupArgs, spawnOptions))
				.subscribe({
					next(line) {
						observer.next({
							id: 'setup',
							command: setupCommand,
							output: line
						});
					},
					error(err) {
						sendError(err, 'setup');
					},
					complete() {
						observer.next({id: 'setup:complete'});
						startBuildOnReady();
					}
				}));
			});
		});

		const download = downloadPurescriptSource(sourceDir, options)
		.subscribe({
			next(progress) {
				progress.id = 'download';
				observer.next(progress);

				const entry = progress.entry;

				if (entry.header.name === 'stack.yaml' && entry.bytes === entry.header.size) {
					setup();
				}
			},
			error(err) {
				sendError(err, 'download');
			},
			complete() {
				setup();
				observer.next({id: 'download:complete'});
				startBuildOnReady();
			}
		});

		subscriptions.add(download);

		return function cancelBuild() {
			for (const subscription of subscriptions) {
				subscription.unsubscribe();
			}
		};
	});
};

Object.defineProperty(module.exports, 'supportedBuildFlags', {
	value: buildOnlyArgs,
	enumerable: true
});
